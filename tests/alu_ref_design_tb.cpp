//==============================================================================
//      File:           $URL$
//      Version:        Automatically generated by 'ATC' script
//      Author:         Rigo Dicochea
//                      Tom Golubev
//                      Jose Renau
//      Copyright:      Copyright 2005 UC Santa Cruz
//==============================================================================

//==============================================================================
//      Section:        License
//==============================================================================
//      Copyright (c) 2005, Regents of the University of California
//      All rights reserved.
//
//      Redistribution and use in source and binary forms, with or without modification,
//      are permitted provided that the following conditions are met:
//
//              - Redistributions of source code must retain the above copyright notice,
//                      this list of conditions and the following disclaimer.
//              - Redistributions in binary form must reproduce the above copyright
//                      notice, this list of conditions and the following disclaimer
//                      in the documentation and/or other materials provided with the
//                      distribution.
//              - Neither the name of the University of California, Santa Cruz nor the
//                      names of its contributors may be used to endorse or promote
//                      products derived from this software without specific prior
//                      written permission.
//
//      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//      ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//      WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//      DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//      ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//      ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//      SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//==============================================================================

/****************************************************************************
    Description:
  //Start DUT variable definition
  BoolType		reset;
  RingPacketType		switch_2_block;
  BoolType		switch_2_blockValid;
  BoolType		switch_2_blockRetry;
  RingPacketType		block_2_switch;
  BoolType		block_2_switchValid;
  BoolType		block_2_switchRetry;
  ReclkControlType		input rce1;
  ReclkControlType		input rce2;
  ReclkFailureType		rctf1;
  ReclkFailureType		rctf2;


	//This data structure defines the "usable" data processed by node

  typedef struct packed{
    RingAddrType    srcid;   //4 bits
    RingAddrType    destid;  //4 bits
    RingCmdType     cmd;     //1 bits
    RingOpcodeType  opcode;  //7 bits
    RingloadType    data;    //64 bits
  }RingPacketType;  //80 bits


****************************************************************************/

#include <iostream>
#include <ctime>
#include <cstdlib>
#include <iomanip>
#include <time.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include "vpi_user.h"
#include "veriuser.h"

#include "atc_fns.h"

#include "alu_ref_design_tb.h"
#include "alu_ref_design_ttb.h"

#ifdef MODELSIM
typedef PLI_INT32 PLIType;
#else
typedef uint32_t PLIType;
#endif

#define GLOBAL_PRINT  0
#define DEBUG_PRINT   0

using namespace std;

uint64_t NUM_EXECUTE_CYCLES = 1000;
uint64_t num_total_ops = 0;

uint32_t any_failure = 0;
uint32_t total_num_valid_inst = 0;

unsigned char	last_stop 		= 0;
unsigned char 	stop 			= 0;

#define STOP 1

#define CYCLES_HOLD_RESET   10
#define MAX_INST			100000
#define ADDITION			0
#define LEFT_SHIFT			1
#define RIGHT_SHIFT			2
#define MULT				3
#define SUBTRACTION			4

#define RANDOM_STOP			(rand() % 100)
#define PERCENT_STOP		20
#define WORKLOAD_NUM		(rand() % 100)
#define WORKLOAD			80

//Useful debugging macros, debugging and error message macros so we can pin down message provenance at a glance
#define DEBUGPRINT2(...)       vpi_printf(__VA_ARGS__)
#define ALWAYSPRINT(_fmt, ...)  DEBUGPRINT2(DBGSTR _fmt, WHEREARG, __VA_ARGS__)
#define ERRORPRINT(_fmt, ...)  DEBUGPRINT2(ERRSTR _fmt, WHEREARG, __VA_ARGS__)

//States in the state machine
#define RESET 			    			0
#define STATE_SEND_ADD_INST				1
#define STATE_SEND_SL_INST				2
#define STATE_SEND_SR_INST				3
#define STATE_SEND_MULT_INST			4
#define STATE_SEND_SUB_INST				5
#define END								6

//For the state machine
unsigned char state		=0;
unsigned char nextstate	=0;

struct instruction_t
{
	unsigned char		reset;
	unsigned char		stop;
	unsigned char		instValid_next;
	unsigned char		ALUop_next;
	unsigned char		shamt_next;
	uint32_t			data1_next;
	uint32_t			data2_next;

    unsigned char		outValid;
	int32_t             out;
};


int32_t		    	srcid;   //4 bits
int32_t			    destid;  //4 bits
int32_t			    cmd;     //1 bits
//payload
int32_t				opcode;  //7 bits

int32_t				data0;	 //32 bits
//The above data structures are not used by the node, srcid, destid, cmd
int32_t				data1;   //32 bits
int32_t				data2;   //32 bits

struct instruction_t                    instr_at[MAX_INST];

int32_t             d_out				= 0;

int32_t             back_fifo			= 0;
int32_t             mid0_fifo			= 0;
int32_t             mid1_fifo			= 0;
int32_t             front_fifo			= 0;
int32_t				front_fifo_buffer	= 0;

int32_t             tmp_fifo			= 0;


void alu_ref_design_tb_init() {

  int32_t time_seed = time(0);

 	vpi_printf("@D Running for %d cycles\n", NUM_EXECUTE_CYCLES);

	char *opt = mc_scan_plusargs("print=");
	// Handle RNG Seeding
	opt = mc_scan_plusargs("seed=");
	if (opt) {
		time_seed = atoi(opt);
	}
 	time_seed = 1240608344; //FIXME: remove, just for debugging
	//srand ( time_seed ); // seed RNG

	vpi_printf("\t\t\tTestbench Seeded with %d\n\n", time_seed);

	//vpi_printf("Reset is set high for: %d cycles\n", CYCLES_HOLD_RESET);

	//state                               = RESET;
	//nextstate							  = RESET;
}// /alu_ref_design_tb_init()


// Check if operation produced the correct result
void alu_ref_design_tb_check(alu_ref_design_ * dut) {
	vpi_printf("@D *************alu_ref_design_tb check()*************\n");

	//Check these outputs from the alu_ref_design block
	//BoolType(1 bit)          	switch_2_blockRetry
	//BoolType(1 bit)          	block_2_switchValid
    //RingPacketType(80 bits)   block_2_switch

	unsigned char				block_2_switchValid;

	unsigned char				block_2_switch_srcid;
	unsigned char				block_2_switch_destid;
	unsigned char				block_2_switch_cmd;

	uint32_t					block_2_switch_opcode;
	uint32_t					block_2_switch_data1;
	uint32_t					block_2_switch_data2;


	block_2_switchValid		= dut->block_2_switchValid.to_i();

    block_2_switch_srcid    = dut->block_2_switch.srcid.to_i();
	block_2_switch_destid   = dut->block_2_switch.destid.to_i();
	block_2_switch_cmd      = dut->block_2_switch.cmd.to_i();

	block_2_switch_opcode       = dut->block_2_switch.opcode.to_i();//io_uint32_t_read(0);
	block_2_switch_data1        = dut->block_2_switch.data.io_uint32_t_read(1);
	block_2_switch_data2        = dut->block_2_switch.data.io_uint32_t_read(0);

	#ifdef JEFE

	#endif

	if(STOP == 0)
	{
		vpi_printf("\nfront_fifo: %d\n", front_fifo);
		vpi_printf("\nfront_fifo_buffer: %d\n", front_fifo_buffer);

		if( (block_2_switchValid) && (num_total_ops > 5) )
		{
			vpi_printf("block_2_switchValid: %d block_2_switch_srcid: %d block_2_switch_destid: %d\nblock_2_switch_cmd: %d block_2_switch_opcode: %d block_2_switch_data1: %d\nblock_2_switch_data2: %d\n", block_2_switchValid, block_2_switch_srcid, block_2_switch_destid, block_2_switch_cmd, block_2_switch_opcode, block_2_switch_data1, block_2_switch_data2);

			if(block_2_switch_data2 == front_fifo_buffer)
			{
		    	vpi_printf("\nYou are so smart!\n");
		    	vpi_printf("Cycle: %d Hardware result valid: %d Hardware result: %d \n", num_total_ops, block_2_switchValid, block_2_switch_data2);
				vpi_printf("Cycle: %d Software result: %d \n\n", num_total_ops, front_fifo_buffer);
        	}
			else
        	{
				any_failure = 1;

		    	vpi_printf("\nERROR, you dummy fix the code!\n");
		    	vpi_printf("Cycle: %d Hardware result valid: %d Hardware result: %d \n", num_total_ops, block_2_switchValid, block_2_switch_data2);
				vpi_printf("Cycle: %d Software result: %d \n\n", num_total_ops, front_fifo_buffer);
        	}
		}
		last_stop = stop;
	}

	if(STOP == 1)
	{
		if( (block_2_switchValid) )
		{
			for(int j = num_total_ops; j--; ( (j == num_total_ops - 20) || (j == 0) ) )
			{
				if(block_2_switch_data2 == instr_at[j].out)
				{
					any_failure = 0;

					vpi_printf("\nYou are so smart!\n");
		    		vpi_printf("Cycle: %d Hardware result valid: %d Hardware result: %d \n", num_total_ops, block_2_switchValid, block_2_switch_data2);
					vpi_printf("Cycle: %d Software result: %d \n\n", num_total_ops, instr_at[j].out);

					break;
				}
				else
				{
					any_failure = 1;
				}
			}
			if( any_failure == 1 )
			{
		    		vpi_printf("\nERROR, you dummy fix the code!\n");
		    		vpi_printf("Cycle: %d Hardware result valid: %d Hardware result: %d \n", num_total_ops, block_2_switchValid, block_2_switch_data2);
					vpi_printf("Cycle: %d Software result: %d \n\n", num_total_ops, instr_at[num_total_ops].out);
			}
		}
	}

}// /alu_ref_design_tb_check()


/* The main function, set all the data inputs
   This fn is independant of alu_ref_design_tb_check(), to increase verification and isolation of check and set functions*/
void alu_ref_design_tb_set(alu_ref_design_ * dut) {
	//Set these inputs for alu_ref_design module
	//RingPacketType(80 bits) 	switch_2_block
	//BoolType(1 bit)        	switch_2_blockValid
	//BoolType(1 bit)			switch_2_blockRetry

	//write
	//dut->ext_req_vector.io_uint32_t_write(0,0x00000000);
    //dut->ext_req_vector.io_uint32_t_write(1,0x00000000);
    //dut->ext_req_vector.io_uint32_t_write(2,0x00000000);
    //dut->ext_req_vector.io_uint32_t_write(3,0x00000000);
	//////////////////////////////////////////////////////
	vpi_printf("\n\n		    ********Cycle: %d********\n", num_total_ops);
	vpi_printf("@D *********************alu_ref_design_tb set()*********************\n");

	unsigned char valid;
	if(WORKLOAD_NUM <= WORKLOAD)
	{
		valid						= 1;
	}
	else
	{
		valid						= 0;
	}

	int32_t data1;
    int32_t data2;
  	data1 							= rand() % 150;
	data2							= rand() % 150;

	state   						=   nextstate;

  // alu_ref_design_tb_set CODE START
  switch (state)
  {
    case RESET: //Set reset in the first cycle
      vpi_printf("\nCycle: %d Reset is high!\n", num_total_ops);

      if(num_total_ops >= CYCLES_HOLD_RESET) {
        //vpi_printf("\nCycle: %d Reset is High for %d cycles\n", num_total_ops, CYCLES_HOLD_RESET);
        nextstate                       = STATE_SEND_ADD_INST; //rand() % 7;
      } else {
        dut->reset                      	= 1;

        dut->switch_2_blockValid								= 0;
        dut->switch_2_block.srcid.io_uint32_t_write(0,0x00000000);
        dut->switch_2_block.destid.io_uint32_t_write(1,0x00000000);
        dut->switch_2_block.cmd.io_uint32_t_write(1,0x00000000);
        dut->switch_2_block.opcode.io_uint32_t_write(1,0x00000000);
        dut->switch_2_block.data.io_uint32_t_write(1,0x00000000);
        dut->switch_2_blockRetry          						= 0;
        dut->block_2_switchRetry          = 0;

        nextstate                         	= RESET;
      }

      break;

    case STATE_SEND_ADD_INST: //Set reset in the first cycle
      //status contains timestamp of when inst. is issued
      instr_at[num_total_ops].reset	          	  = 0; //change to random generation


      if(RANDOM_STOP < PERCENT_STOP)
      {
        instr_at[num_total_ops].stop         	  = STOP;
        stop = instr_at[num_total_ops].stop;
        //vpi_printf("Cycle: %d SET stop: %d \n", num_total_ops, stop);

        instr_at[num_total_ops].instValid_next    = instr_at[num_total_ops - 1].instValid_next;
        instr_at[num_total_ops].ALUop_next        = instr_at[num_total_ops - 1].ALUop_next;
        instr_at[num_total_ops].shamt_next        = instr_at[num_total_ops - 1].shamt_next;
        instr_at[num_total_ops].data1_next        = instr_at[num_total_ops - 1].data1_next;
        instr_at[num_total_ops].data2_next        = instr_at[num_total_ops - 1].data2_next;

        instr_at[num_total_ops].outValid          = instr_at[num_total_ops - 1].outValid;
        instr_at[num_total_ops].out               = instr_at[num_total_ops - 1].out;
        if(STOP == 1)
        {
          vpi_printf("Random STOP Asserted!\n\n");
        }
      }
      else
      {
        instr_at[num_total_ops].stop         	  = 0;
        stop = instr_at[num_total_ops].stop;

        instr_at[num_total_ops].instValid_next    = valid;
        instr_at[num_total_ops].ALUop_next        = ADDITION;
        instr_at[num_total_ops].shamt_next        = 4;
        instr_at[num_total_ops].data1_next        = data1;
        instr_at[num_total_ops].data2_next        = data2;

        instr_at[num_total_ops].outValid          = valid;
        instr_at[num_total_ops].out               = instr_at[num_total_ops].data1_next + instr_at[num_total_ops].data2_next;
      }

      dut->reset                      = instr_at[num_total_ops].reset;

      data0 = instr_at[num_total_ops].instValid_next;

      data1 = instr_at[num_total_ops].data1_next;//top 4 bits of data1 are used as alu_op_next(ALWAYS ADD)

      data2 = instr_at[num_total_ops].data2_next;
      vpi_printf("Cycle: %d \n", num_total_ops);
      vpi_printf("\nCURRENT INST: instValid: %d data1: %d , data2: %d RESULT: %d\n\n", instr_at[num_total_ops].instValid_next, instr_at[num_total_ops].data1_next, instr_at[num_total_ops].data2_next, instr_at[num_total_ops].data1_next + instr_at[num_total_ops].data2_next) ;

      dut->switch_2_blockValid			= instr_at[num_total_ops].instValid_next;

      dut->switch_2_block.srcid = 0;
      dut->switch_2_block.destid = 1;
      dut->switch_2_block.cmd = 0;

      dut->switch_2_block.opcode = instr_at[num_total_ops].instValid_next;
      //dut->switch_2_block.opcode = 4;
      dut->switch_2_block.data.io_uint32_t_write(1,instr_at[num_total_ops].data1_next);
      dut->switch_2_block.data.io_uint32_t_write(0,instr_at[num_total_ops].data2_next);

      dut->rci0 = 0;

      vpi_printf("block_2_switchRetry: %d\n", instr_at[num_total_ops].stop);
      dut->block_2_switchRetry          = instr_at[num_total_ops].stop;


      nextstate                         = STATE_SEND_ADD_INST;//rand() % 7;
      if(nextstate == RESET)
      {
        nextstate = nextstate + 1;
      }

      if(nextstate == END)
      {
        nextstate = nextstate - 1;
      }

      //front_fifo = out
      //mid0_fifo  = delay_1
      //mid1_fifo  =
      //back_fifo  = out_next
      //vpi_printf("Cycle: %d front_fifo: %d mid0_fifo: %d mid1_fifo: %d back_fifo: %d tmp_fifo: %d\n", num_total_ops, front_fifo, mid0_fifo, mid1_fifo, back_fifo, tmp_fifo);
      if(num_total_ops <= CYCLES_HOLD_RESET)
      {
        front_fifo_buffer = 0;
        front_fifo = 0;
        mid0_fifo  = 0;
        mid1_fifo  = 0;
        back_fifo  = 0;
      }else if( (stop == 0) && (last_stop == 0) )
      {
        front_fifo_buffer = front_fifo;
        front_fifo = mid0_fifo;
        mid0_fifo  = mid1_fifo;
        mid1_fifo  = back_fifo;
        back_fifo  = instr_at[num_total_ops].out;
      }else if( (stop == 0) && (last_stop == 1) )
      {
        //front_fifo = tmp_fifo;
        //mid0_fifo  = mid1_fifo;
        //mid1_fifo  = back_fifo;
        //back_fifo  = instr_at[num_total_ops].out;

        front_fifo_buffer = front_fifo;
        front_fifo = tmp_fifo;
        mid0_fifo  = mid1_fifo;
        mid1_fifo  = back_fifo;
        back_fifo  = instr_at[num_total_ops].out;
        //vpi_printf("Cycle: %d front_fifo: %d mid0_fifo: %d mid1_fifo: %d back_fifo: %d tmp_fifo: %d\n", num_total_ops, front_fifo, mid0_fifo, mid1_fifo, back_fifo, tmp_fifo);
      }else if( (stop == 1) && (last_stop == 0) )
      {
        front_fifo_buffer = front_fifo;
        front_fifo  = mid0_fifo;
        tmp_fifo	= mid0_fifo;
        mid0_fifo   = mid1_fifo;
        mid1_fifo   = mid1_fifo;
        back_fifo   = back_fifo;
        //vpi_printf("Cycle: %d front_fifo: %d mid0_fifo: %d mid1_fifo: %d back_fifo: %d tmp_fifo: %d\n", num_total_ops, front_fifo, mid0_fifo, mid1_fifo, back_fifo, tmp_fifo);
      }else if ( (stop == 1) && (last_stop == 1) )
      {
        front_fifo_buffer = front_fifo;
        front_fifo  = front_fifo;
        mid0_fifo   = mid0_fifo;
        mid1_fifo   = mid1_fifo;
        back_fifo   = instr_at[num_total_ops].out;
      }

      if( instr_at[num_total_ops].instValid_next == 1)
      {
        total_num_valid_inst = total_num_valid_inst + 1;
      }
      break;

    case STATE_SEND_SL_INST: //Set reset in the first cycle
      //status contains timestamp of when inst. is issued
      instr_at[num_total_ops].reset	          = 0; //change to random generation
      instr_at[num_total_ops].stop         = RANDOM_STOP; //change to random generation
      //if(instr_at[num_total_ops].stop)
      //{
      //	stop = stop + 1;
      //}
      instr_at[num_total_ops].instValid_next    = valid;
      instr_at[num_total_ops].ALUop_next        = LEFT_SHIFT;
      instr_at[num_total_ops].shamt_next        = (rand() % 2);
      instr_at[num_total_ops].data1_next        = data1;
      instr_at[num_total_ops].data2_next        = data2;

      instr_at[num_total_ops].outValid          = instr_at[num_total_ops].instValid_next;
      instr_at[num_total_ops].out               = instr_at[num_total_ops].data1_next << instr_at[num_total_ops].shamt_next;

      if(DEBUG_PRINT)
      {
        vpi_printf("\nIssued On Cycle: %d  \nSOFTWARE: reset: %d stop: %d instValid_next: %d ALUop_next: %d shamt_next: %d data1_next: %d data2_next: %d outValid: %d  out: %d \n\n",
            num_total_ops, instr_at[num_total_ops].reset, instr_at[num_total_ops].stop, instr_at[num_total_ops].instValid_next, instr_at[num_total_ops].ALUop_next, instr_at[num_total_ops].shamt_next,
            instr_at[num_total_ops].data1_next, instr_at[num_total_ops].data2_next, instr_at[num_total_ops].outValid, instr_at[num_total_ops].out);
      }

      dut->reset                      = instr_at[num_total_ops].reset;
      //dut->stop						= instr_at[num_total_ops].stop;
      //dut->instValid_next				= instr_at[num_total_ops].instValid_next;
      //dut->ALUop_next                 = instr_at[num_total_ops].ALUop_next;
      //dut->shamt_next					= instr_at[num_total_ops].shamt_next;
      //dut->data1_next					= instr_at[num_total_ops].data1_next;
      //dut->data2_next					= instr_at[num_total_ops].data2_next;

      nextstate                       = rand() % 7;
      if(nextstate == RESET)
      {
        nextstate = nextstate + 1;
      }

      if(nextstate == END)
      {
        nextstate = nextstate - 1;
      }
      break;

    case STATE_SEND_SR_INST: //Set reset in the first cycle
      //status contains timestamp of when inst. is issued
      instr_at[num_total_ops].reset	          = 0; //change to random generation
      instr_at[num_total_ops].stop         	  = RANDOM_STOP; //change to random generation
      //if(instr_at[num_total_ops].stop)
      //{
      //	stop = stop + 1;
      //}
      instr_at[num_total_ops].instValid_next    = valid;
      instr_at[num_total_ops].ALUop_next        = RIGHT_SHIFT;
      instr_at[num_total_ops].shamt_next        = (rand() % 2);
      instr_at[num_total_ops].data1_next        = data1;
      instr_at[num_total_ops].data2_next        = data2;

      instr_at[num_total_ops].outValid          = instr_at[num_total_ops].instValid_next;
      instr_at[num_total_ops].out               = instr_at[num_total_ops].data1_next >> instr_at[num_total_ops].shamt_next;

      if(DEBUG_PRINT)
      {
        vpi_printf("\nIssued On Cycle: %d  \nSOFTWARE: reset: %d stop: %d instValid_next: %d ALUop_next: %d shamt_next: %d data1_next: %d data2_next: %d outValid: %d  out: %d \n\n",
            num_total_ops, instr_at[num_total_ops].reset, instr_at[num_total_ops].stop, instr_at[num_total_ops].instValid_next, instr_at[num_total_ops].ALUop_next, instr_at[num_total_ops].shamt_next,
            instr_at[num_total_ops].data1_next, instr_at[num_total_ops].data2_next, instr_at[num_total_ops].outValid, instr_at[num_total_ops].out);
      }

      dut->reset                      = instr_at[num_total_ops].reset;
      //dut->stop						= instr_at[num_total_ops].stop;
      //dut->instValid_next				= instr_at[num_total_ops].instValid_next;
      //dut->ALUop_next                 = instr_at[num_total_ops].ALUop_next;
      //dut->shamt_next					= instr_at[num_total_ops].shamt_next;
      //dut->data1_next					= instr_at[num_total_ops].data1_next;
      //dut->data2_next					= instr_at[num_total_ops].data2_next;

      nextstate                       = rand() % 7;
      if(nextstate == RESET)
      {
        nextstate = nextstate + 1;
      }

      if(nextstate == END)
      {
        nextstate = nextstate - 1;
      }
      break;

    case STATE_SEND_MULT_INST: //Set reset in the first cycle
      //status contains timestamp of when inst. is issued
      instr_at[num_total_ops].reset	          = 0; //change to random generation
      instr_at[num_total_ops].stop         	  = RANDOM_STOP; //change to random generation
      //if(instr_at[num_total_ops].stop)
      //{
      //	stop = stop + 1;
      //}
      instr_at[num_total_ops].instValid_next    = valid;
      instr_at[num_total_ops].ALUop_next        = MULT;
      instr_at[num_total_ops].shamt_next        = 0;
      instr_at[num_total_ops].data1_next        = data1;
      instr_at[num_total_ops].data2_next        = data2;

      instr_at[num_total_ops].outValid          = instr_at[num_total_ops].instValid_next;
      instr_at[num_total_ops].out               = instr_at[num_total_ops].data1_next * instr_at[num_total_ops].data2_next;

      if(DEBUG_PRINT)
      {
        vpi_printf("\nIssued On Cycle: %d  \nSOFTWARE: reset: %d stop: %d instValid_next: %d ALUop_next: %d shamt_next: %d data1_next: %d data2_next: %d outValid: %d  out: %d \n\n",
            num_total_ops, instr_at[num_total_ops].reset, instr_at[num_total_ops].stop, instr_at[num_total_ops].instValid_next, instr_at[num_total_ops].ALUop_next, instr_at[num_total_ops].shamt_next,
            instr_at[num_total_ops].data1_next, instr_at[num_total_ops].data2_next, instr_at[num_total_ops].outValid, instr_at[num_total_ops].out);
      }

      dut->reset                      = instr_at[num_total_ops].reset;
      //dut->stop						= instr_at[num_total_ops].stop;
      //dut->instValid_next				= instr_at[num_total_ops].instValid_next;
      //dut->ALUop_next                 = instr_at[num_total_ops].ALUop_next;
      //dut->shamt_next					= instr_at[num_total_ops].shamt_next;
      //dut->data1_next					= instr_at[num_total_ops].data1_next;
      //dut->data2_next					= instr_at[num_total_ops].data2_next;

      nextstate                       = rand() % 7;
      if(nextstate == RESET)
      {
        nextstate = nextstate + 1;
      }

      if(nextstate == END)
      {
        nextstate = nextstate - 1;
      }
      break;

    case STATE_SEND_SUB_INST: //Set reset in the first cycle
      //status contains timestamp of when inst. is issued
      instr_at[num_total_ops].reset	          = 0; //change to random generation
      instr_at[num_total_ops].stop         	  = RANDOM_STOP; //change to random generation
      //if(instr_at[num_total_ops].stop)
      //{
      //	stop = stop + 1;
      //}
      instr_at[num_total_ops].instValid_next    = valid;
      instr_at[num_total_ops].ALUop_next        = SUBTRACTION;
      instr_at[num_total_ops].shamt_next        = (rand() % 4);
      instr_at[num_total_ops].data1_next        = data1;
      instr_at[num_total_ops].data2_next        = data2;

      instr_at[num_total_ops].outValid          = instr_at[num_total_ops].instValid_next;
      instr_at[num_total_ops].out               = instr_at[num_total_ops].data1_next - instr_at[num_total_ops].data2_next;

      if(DEBUG_PRINT)
      {
        vpi_printf("\nIssued On Cycle: %d  \nSOFTWARE: reset: %d stop: %d instValid_next: %d ALUop_next: %d shamt_next: %d data1_next: %d data2_next: %d outValid: %d  out: %d \n\n",
            num_total_ops, instr_at[num_total_ops].reset, instr_at[num_total_ops].stop, instr_at[num_total_ops].instValid_next, instr_at[num_total_ops].ALUop_next, instr_at[num_total_ops].shamt_next,
            instr_at[num_total_ops].data1_next, instr_at[num_total_ops].data2_next, instr_at[num_total_ops].outValid, instr_at[num_total_ops].out);
      }

      dut->reset                      = instr_at[num_total_ops].reset;
      //dut->stop						= instr_at[num_total_ops].stop;
      //dut->instValid_next				= instr_at[num_total_ops].instValid_next;
      //dut->ALUop_next                 = instr_at[num_total_ops].ALUop_next;
      //dut->shamt_next					= instr_at[num_total_ops].shamt_next;
      //dut->data1_next					= instr_at[num_total_ops].data1_next;
      //dut->data2_next					= instr_at[num_total_ops].data2_next;

      nextstate                       = rand() % 7;
      if(nextstate == RESET)
      {
        nextstate = nextstate + 1;
      }

      if(nextstate == END)
      {
        nextstate = nextstate - 1;
      }
      break;

    case END: //Set reset in the first cycle
      dut->reset                        = 0;

      //dut->stop					  	  = 0;
      //dut->instValid_next				  = 0;
      //dut->ALUop_next                   = 0;
      //dut->shamt_next					  = 0;
      //dut->data1_next					  = 0;
      //dut->data2_next					  = 0;

      nextstate                         = END;
      break;

    default:
      ERRORPRINT("Testbench error: Unknown state: %d  Next state: %d\n", state, nextstate);
      nextstate                         = STATE_SEND_ADD_INST;
      break;
  }
}// /alu_ref_design_tb_set()


// Print all errors, summary, free memory
void alu_ref_design_tb_end() {
	vpi_printf("\n\n");

	if(any_failure != 0)
    {
        vpi_printf("Dummy you failed, go fix it!!!!");
    }
    else
    {
		vpi_printf("TOTAL CYCLES: %d\nSTATS: TOTAL VALID INST: %d STOP ASSERTED %d PERCENT OF THE TIME\n\n", num_total_ops, total_num_valid_inst, PERCENT_STOP);
        vpi_printf("YOU MIGHT BE THE SMARTEST PERSON IN THE WORLD, Great Job :), Galations 2:20!!!!\n\n");
    }

	vpi_printf("\n%d Clock Cycles Total alu_ref_design_tb FINISHED\n", num_total_ops);

}// /alu_ref_design_tb_end()


//   Automatically Generated by handles.rb
